name: CI Build Monitor

on:
  workflow_dispatch:
  schedule:
    - cron: "0 * * * *" # hourly

permissions:
  contents: write
  actions: read

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate CI status markdown
        id: gen
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // List all workflows in the repo
            const { data: workflowsData } = await github.rest.actions.listRepoWorkflows({ owner, repo, per_page: 100 });
            const workflows = (workflowsData.workflows || [])
              .filter(w => !!w.name)
              .sort((a, b) => a.name.localeCompare(b.name));

            const tableRows = [];

            for (const w of workflows) {
              // Get the latest run for each workflow
              const { data: runsData } = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: w.id, per_page: 1 });
              const run = (runsData.workflow_runs || [])[0];

              const status = run?.status || 'n/a';
              const conclusion = run?.conclusion || 'n/a';
              const event = run?.event || 'n/a';
              const sha = run?.head_sha ? run.head_sha.substring(0, 7) : 'n/a';
              const fullSha = run?.head_sha || 'n/a';
              const branch = run?.head_branch || 'n/a';
              const url = run?.html_url || w.html_url;
              const started = run?.run_started_at || run?.created_at || null;
              const completed = run?.completed_at || run?.updated_at || null;
              const lastRun = completed || started || null;
              let lastRunDisplay = 'n/a';
              if (lastRun) {
                try { lastRunDisplay = new Date(lastRun).toISOString(); } catch { lastRunDisplay = String(lastRun); }
              }

              let duration = 'n/a';
              if (started && completed) {
                const dSec = (new Date(completed) - new Date(started)) / 1000;
                const mins = Math.floor(dSec / 60);
                const secs = Math.floor(dSec % 60);
                duration = `${mins}m ${secs}s`;
              }

              const emojiMap = { success: 'âœ…', failure: 'âŒ', cancelled: 'ğŸš«', neutral: 'â–«ï¸', timed_out: 'â±ï¸', action_required: 'ğŸŸ¡', skipped: 'â¤´ï¸' };
              const emoji = emojiMap[conclusion] || 'â“';

              // Smart URL - for failures, link to details anchor; for success, to the build
              const workflowId = w.name.toLowerCase().replace(/\s+/g, '-');
              const smartUrl = (conclusion === 'failure' || conclusion === 'timed_out') ? `[â¬‡ï¸ Details](#${workflowId})` : `[View](${url})`;

              // Main table row (removed SHA column)
              tableRows.push(`| ${w.name} | ${status} | ${emoji} ${conclusion} | ${event} | ${lastRunDisplay} | ${branch} | ${duration} | ${smartUrl} |`);

              // Add detailed failure information as collapsible row
              if (conclusion === 'failure' || conclusion === 'timed_out') {
                let author = 'Unknown';
                let commitMessage = '';
                let commitUrl = '';

                if (fullSha !== 'n/a') {
                  try {
                    const { data: commit } = await github.rest.repos.getCommit({ owner, repo, ref: fullSha });
                    author = commit.commit.author.name;
                    commitMessage = commit.commit.message.split('\n')[0]; // First line only
                    commitUrl = commit.html_url;
                  } catch (e) {
                    console.log(`Could not fetch commit info for ${fullSha}: ${e.message}`);
                  }
                }

                // Get failed jobs
                let failedJobs = [];
                if (run?.id) {
                  try {
                    const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({ owner, repo, run_id: run.id });
                    failedJobs = (jobsData.jobs || [])
                      .filter(j => j.conclusion === 'failure' || j.conclusion === 'timed_out')
                      .map(j => ({ name: j.name, url: j.html_url, conclusion: j.conclusion }));
                  } catch (e) {
                    console.log(`Could not fetch jobs for run ${run.id}: ${e.message}`);
                  }
                }

                // Create issue link with pre-filled details
                const issueTitle = encodeURIComponent(`CI Failure: ${w.name} on ${branch}`);
                const issueBody = encodeURIComponent(
                  `## CI Build Failure\n\n` +
                  `**Workflow:** ${w.name}\n` +
                  `**Branch:** ${branch}\n` +
                  `**Commit:** ${sha} - ${commitMessage}\n` +
                  `**Author:** @${author}\n` +
                  `**Run:** ${url}\n\n` +
                  `### Failed Jobs\n` +
                  (failedJobs.length ? failedJobs.map(j => `- [${j.name}](${j.url}) - ${j.conclusion}`).join('\n') : 'No job details available') +
                  `\n\n### Action Required\n` +
                  `Please investigate and fix the failing build.\n`
                );
                const createIssueUrl = `https://github.com/${owner}/${repo}/issues/new?title=${issueTitle}&body=${issueBody}&assignees=${author}`;

                // Add collapsible details row (compact format, removed SHA column)
                const failedJobsList = failedJobs.map(j => `[${j.name}](${j.url})`).join(', ') || 'N/A';
                tableRows.push(`| <details id="${workflowId}"><summary>ğŸ“‹ <strong>Failure Details</strong></summary><br/><br/>**Commit:** [\`${sha}\`](${commitUrl})<br/>**Author:** ${author}<br/>**Failed Jobs:** ${failedJobsList}<br/>**Actions:** [ğŸ‘¤ Assign to Author](${createIssueUrl}) â€¢ [ğŸ”— View Run](${url})</details> | | | | | | | |`);
              }
            }

            // Build the markdown content
            let content = `# CI Build Monitor\n\n`;
            content += `Last updated: ${new Date().toISOString()}\n\n`;

            // Summary section
            const totalWorkflows = workflows.length;
            const successCount = tableRows.filter(r => r.includes('âœ…')).length;
            const failureCount = tableRows.filter(r => r.includes('âŒ')).length;
            const cancelledCount = tableRows.filter(r => r.includes('ğŸš«')).length;
            const timedOutCount = tableRows.filter(r => r.includes('â±ï¸')).length;

            content += `## Summary\n\n`;
            content += `- **Total Workflows:** ${totalWorkflows}\n`;
            content += `- **âœ… Successful:** ${successCount}\n`;
            content += `- **âŒ Failed:** ${failureCount}\n`;
            content += `- **ğŸš« Cancelled:** ${cancelledCount}\n`;
            content += `- **â±ï¸ Timed Out:** ${timedOutCount}\n\n`;

            // All workflows table with inline collapsible details
            content += `## All Workflows\n\n`;
            content += `ğŸ’¡ *Failed workflows show â¬‡ï¸ Details - click to expand inline. Successful workflows show View link.*\n\n`;
            content += '| Workflow | Status | Conclusion | Event | Last Run | Branch | Duration | URL |\n';
            content += '|---|---|---|---|---|---|---|---|\n';
            content += tableRows.length ? tableRows.join('\n') + '\n' : '_No workflows found_\n';

            fs.writeFileSync('CI_STATUS.md', content);

      - name: Commit CI_STATUS.md update
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "CI monitor: update CI_STATUS.md"
          file_pattern: "CI_STATUS.md"
