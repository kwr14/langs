name: CI Build Monitor

on:
  workflow_dispatch:
  schedule:
    - cron: "0 * * * *" # hourly

permissions:
  contents: write
  actions: read

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate CI status markdown
        id: gen
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // List all workflows in the repo
            const { data: workflowsData } = await github.rest.actions.listRepoWorkflows({ owner, repo, per_page: 100 });
            const workflows = (workflowsData.workflows || [])
              .filter(w => !!w.name)
              .sort((a, b) => a.name.localeCompare(b.name));

            const rows = [];
            const failureDetails = [];

            for (const w of workflows) {
              // Get the latest run for each workflow
              const { data: runsData } = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: w.id, per_page: 1 });
              const run = (runsData.workflow_runs || [])[0];

              const status = run?.status || 'n/a';
              const conclusion = run?.conclusion || 'n/a';
              const event = run?.event || 'n/a';
              const sha = run?.head_sha ? run.head_sha.substring(0, 7) : 'n/a';
              const fullSha = run?.head_sha || 'n/a';
              const branch = run?.head_branch || 'n/a';
              const url = run?.html_url || w.html_url;
              const started = run?.run_started_at || run?.created_at || null;
              const completed = run?.completed_at || run?.updated_at || null;
              const lastRun = completed || started || null;
              let lastRunDisplay = 'n/a';
              if (lastRun) {
                try { lastRunDisplay = new Date(lastRun).toISOString(); } catch { lastRunDisplay = String(lastRun); }
              }

              let duration = 'n/a';
              if (started && completed) {
                const dSec = (new Date(completed) - new Date(started)) / 1000;
                const mins = Math.floor(dSec / 60);
                const secs = Math.floor(dSec % 60);
                duration = `${mins}m ${secs}s`;
              }

              const emojiMap = { success: '‚úÖ', failure: '‚ùå', cancelled: 'üö´', neutral: '‚ñ´Ô∏è', timed_out: '‚è±Ô∏è', action_required: 'üü°', skipped: '‚§¥Ô∏è' };
              const emoji = emojiMap[conclusion] || '‚ùì';

              // Create a sanitized anchor ID for linking
              const anchorId = w.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');

              // Add details link for failed workflows
              const detailsLink = (conclusion === 'failure' || conclusion === 'timed_out')
                ? `[üìã Details](#${anchorId})`
                : '';

              rows.push(`| ${w.name} | ${status} | ${emoji} ${conclusion} | ${event} | ${lastRunDisplay} | ${sha} | ${branch} | ${duration} | [link](${url}) | ${detailsLink} |`);

              // Collect detailed failure information
              if (conclusion === 'failure' || conclusion === 'timed_out') {
                let commitInfo = null;
                let author = 'Unknown';
                let authorEmail = '';
                let commitMessage = '';
                let commitUrl = '';

                if (fullSha !== 'n/a') {
                  try {
                    const { data: commit } = await github.rest.repos.getCommit({ owner, repo, ref: fullSha });
                    author = commit.commit.author.name;
                    authorEmail = commit.commit.author.email;
                    commitMessage = commit.commit.message.split('\n')[0]; // First line only
                    commitUrl = commit.html_url;
                  } catch (e) {
                    console.log(`Could not fetch commit info for ${fullSha}: ${e.message}`);
                  }
                }

                // Get failed jobs
                let failedJobs = [];
                if (run?.id) {
                  try {
                    const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({ owner, repo, run_id: run.id });
                    failedJobs = (jobsData.jobs || [])
                      .filter(j => j.conclusion === 'failure' || j.conclusion === 'timed_out')
                      .map(j => ({ name: j.name, url: j.html_url, conclusion: j.conclusion }));
                  } catch (e) {
                    console.log(`Could not fetch jobs for run ${run.id}: ${e.message}`);
                  }
                }

                // Create issue link with pre-filled details
                const issueTitle = encodeURIComponent(`CI Failure: ${w.name} on ${branch}`);
                const issueBody = encodeURIComponent(
                  `## CI Build Failure\n\n` +
                  `**Workflow:** ${w.name}\n` +
                  `**Branch:** ${branch}\n` +
                  `**Commit:** ${sha} - ${commitMessage}\n` +
                  `**Author:** @${author}\n` +
                  `**Run:** ${url}\n\n` +
                  `### Failed Jobs\n` +
                  (failedJobs.length ? failedJobs.map(j => `- [${j.name}](${j.url}) - ${j.conclusion}`).join('\n') : 'No job details available') +
                  `\n\n### Action Required\n` +
                  `Please investigate and fix the failing build.\n`
                );
                const createIssueUrl = `https://github.com/${owner}/${repo}/issues/new?title=${issueTitle}&body=${issueBody}&assignees=${author}`;

                failureDetails.push({
                  workflow: w.name,
                  anchorId,
                  branch,
                  sha,
                  fullSha,
                  commitMessage,
                  commitUrl,
                  author,
                  authorEmail,
                  url,
                  lastRun: lastRunDisplay,
                  duration,
                  conclusion,
                  failedJobs,
                  createIssueUrl
                });
              }
            }

            // Build the markdown content
            let content = `# CI Build Monitor\n\n`;
            content += `Last updated: ${new Date().toISOString()}\n\n`;

            // Summary section
            const totalWorkflows = workflows.length;
            const successCount = rows.filter(r => r.includes('‚úÖ')).length;
            const failureCount = rows.filter(r => r.includes('‚ùå')).length;
            const cancelledCount = rows.filter(r => r.includes('üö´')).length;
            const timedOutCount = rows.filter(r => r.includes('‚è±Ô∏è')).length;

            content += `## Summary\n\n`;
            content += `- **Total Workflows:** ${totalWorkflows}\n`;
            content += `- **‚úÖ Successful:** ${successCount}\n`;
            content += `- **‚ùå Failed:** ${failureCount}\n`;
            content += `- **üö´ Cancelled:** ${cancelledCount}\n`;
            content += `- **‚è±Ô∏è Timed Out:** ${timedOutCount}\n\n`;

            // Failures section with detailed information (collapsible)
            if (failureDetails.length > 0) {
              content += `## ‚ùå Failed Builds - Detailed Information\n\n`;
              content += `Click on each workflow to expand details.\n\n`;

              for (const failure of failureDetails) {
                content += `<details id="${failure.anchorId}">\n`;
                content += `<summary><strong>üî¥ ${failure.workflow}</strong> - ${failure.conclusion === 'failure' ? '‚ùå Failed' : '‚è±Ô∏è Timed Out'} on <code>${failure.branch}</code></summary>\n\n`;

                content += `| Field | Value |\n`;
                content += `|-------|-------|\n`;
                content += `| **Status** | ${failure.conclusion === 'failure' ? '‚ùå Failed' : '‚è±Ô∏è Timed Out'} |\n`;
                content += `| **Branch** | \`${failure.branch}\` |\n`;
                content += `| **Commit** | [\`${failure.sha}\`](${failure.commitUrl}) |\n`;
                content += `| **Message** | ${failure.commitMessage || 'N/A'} |\n`;
                content += `| **Author** | ${failure.author} |\n`;
                content += `| **Last Run** | ${failure.lastRun} |\n`;
                content += `| **Duration** | ${failure.duration} |\n`;
                content += `| **Run URL** | [View Run](${failure.url}) |\n`;
                content += `| **Actions** | [üìù Create Issue & Assign to Author](${failure.createIssueUrl}) |\n\n`;

                if (failure.failedJobs.length > 0) {
                  content += `**Failed Jobs:**\n`;
                  for (const job of failure.failedJobs) {
                    content += `- [${job.name}](${job.url}) - ${job.conclusion}\n`;
                  }
                  content += `\n`;
                }

                content += `</details>\n\n`;
              }
            }

            // All workflows table
            content += `## All Workflows\n\n`;
            content += '| Workflow | Status | Conclusion | Event | Last Run | SHA | Branch | Duration | URL | Details |\n';
            content += '|---|---|---|---|---|---|---|---|---|---|\n';
            content += rows.length ? rows.join('\n') + '\n' : '_No workflows found_\n';

            fs.writeFileSync('CI_STATUS.md', content);

      - name: Commit CI_STATUS.md update
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "CI monitor: update CI_STATUS.md"
          file_pattern: "CI_STATUS.md"
