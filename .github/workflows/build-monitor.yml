name: CI Build Monitor

on:
  workflow_dispatch:
  schedule:
    - cron: "0 * * * *" # hourly

permissions:
  contents: write
  actions: read

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate CI status markdown
        id: gen
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // List all workflows in the repo
            const { data: workflowsData } = await github.rest.actions.listRepoWorkflows({ owner, repo, per_page: 100 });
            const workflows = (workflowsData.workflows || [])
              .filter(w => !!w.name)
              .sort((a, b) => a.name.localeCompare(b.name));

            const tableRows = [];

            for (const w of workflows) {
              // Get the latest run for each workflow
              const { data: runsData } = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: w.id, per_page: 1 });
              const run = (runsData.workflow_runs || [])[0];

              const status = run?.status || 'n/a';
              const conclusion = run?.conclusion || 'n/a';
              const event = run?.event || 'n/a';
              const sha = run?.head_sha ? run.head_sha.substring(0, 7) : 'n/a';
              const fullSha = run?.head_sha || 'n/a';
              const branch = run?.head_branch || 'n/a';
              const url = run?.html_url || w.html_url;
              const started = run?.run_started_at || run?.created_at || null;
              const completed = run?.completed_at || run?.updated_at || null;
              const lastRun = completed || started || null;
              let lastRunDisplay = 'n/a';
              if (lastRun) {
                try { lastRunDisplay = new Date(lastRun).toISOString(); } catch { lastRunDisplay = String(lastRun); }
              }

              let duration = 'n/a';
              if (started && completed) {
                const dSec = (new Date(completed) - new Date(started)) / 1000;
                const mins = Math.floor(dSec / 60);
                const secs = Math.floor(dSec % 60);
                duration = `${mins}m ${secs}s`;
              }

              const emojiMap = { success: '‚úÖ', failure: '‚ùå', cancelled: 'üö´', neutral: '‚ñ´Ô∏è', timed_out: '‚è±Ô∏è', action_required: 'üü°', skipped: '‚§¥Ô∏è' };
              const emoji = emojiMap[conclusion] || '‚ùì';

              // Build smart URL column with embedded collapsible details for failures
              let smartUrl;
              if (conclusion === 'failure' || conclusion === 'timed_out') {
                // Fetch commit and job details for failures
                let author = 'Unknown';
                let commitMessage = '';
                let commitUrl = '';

                if (fullSha !== 'n/a') {
                  try {
                    const { data: commit } = await github.rest.repos.getCommit({ owner, repo, ref: fullSha });
                    author = commit.commit.author.name;
                    commitMessage = commit.commit.message.split('\n')[0]; // First line only
                    commitUrl = commit.html_url;
                  } catch (e) {
                    console.log(`Could not fetch commit info for ${fullSha}: ${e.message}`);
                  }
                }

                // Get failed jobs
                let failedJobs = [];
                if (run?.id) {
                  try {
                    const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({ owner, repo, run_id: run.id });
                    failedJobs = (jobsData.jobs || [])
                      .filter(j => j.conclusion === 'failure' || j.conclusion === 'timed_out')
                      .map(j => ({ name: j.name, url: j.html_url, conclusion: j.conclusion }));
                  } catch (e) {
                    console.log(`Could not fetch jobs for run ${run.id}: ${e.message}`);
                  }
                }

                // Create issue link with pre-filled details
                const issueTitle = encodeURIComponent(`CI Failure: ${w.name} on ${branch}`);
                const issueBody = encodeURIComponent(
                  `## CI Build Failure\n\n` +
                  `**Workflow:** ${w.name}\n` +
                  `**Branch:** ${branch}\n` +
                  `**Commit:** ${sha} - ${commitMessage}\n` +
                  `**Author:** @${author}\n` +
                  `**Run:** ${url}\n\n` +
                  `### Failed Jobs\n` +
                  (failedJobs.length ? failedJobs.map(j => `- [${j.name}](${j.url}) - ${j.conclusion}`).join('\n') : 'No job details available') +
                  `\n\n### Action Required\n` +
                  `Please investigate and fix the failing build.\n`
                );
                const createIssueUrl = `https://github.com/${owner}/${repo}/issues/new?title=${issueTitle}&body=${issueBody}&assignees=${author}`;

                // Build collapsible details in URL column
                const failedJobsList = failedJobs.map(j => `[${j.name}](${j.url})`).join(', ') || 'N/A';
                smartUrl = `<details><summary>‚¨áÔ∏è Details</summary><br/><br/>**Commit:** [\`${sha}\`](${commitUrl})<br/>**Author:** ${author}<br/>**Failed Jobs:** ${failedJobsList}<br/>**Actions:** [üë§ Assign to Author](${createIssueUrl})</details>`;
              } else {
                // For successful builds, just show a link
                smartUrl = `[View](${url})`;
              }

              // Main table row
              tableRows.push(`| ${w.name} | ${status} | ${emoji} ${conclusion} | ${event} | ${lastRunDisplay} | ${branch} | ${duration} | ${smartUrl} |`);
            }

            // Build the markdown content
            let content = `# CI Build Monitor\n\n`;
            content += `Last updated: ${new Date().toISOString()}\n\n`;

            // Summary section
            const totalWorkflows = workflows.length;
            const successCount = tableRows.filter(r => r.includes('‚úÖ')).length;
            const failureCount = tableRows.filter(r => r.includes('‚ùå')).length;
            const cancelledCount = tableRows.filter(r => r.includes('üö´')).length;
            const timedOutCount = tableRows.filter(r => r.includes('‚è±Ô∏è')).length;

            content += `## Summary\n\n`;
            content += `- **Total Workflows:** ${totalWorkflows}\n`;
            content += `- **‚úÖ Successful:** ${successCount}\n`;
            content += `- **‚ùå Failed:** ${failureCount}\n`;
            content += `- **üö´ Cancelled:** ${cancelledCount}\n`;
            content += `- **‚è±Ô∏è Timed Out:** ${timedOutCount}\n\n`;

            // All workflows table with inline collapsible details
            content += `## All Workflows\n\n`;
            content += `üí° *Failed workflows show ‚¨áÔ∏è Details - click to expand inline. Successful workflows show View link.*\n\n`;
            content += '| Workflow | Status | Conclusion | Event | Last Run | Branch | Duration | URL |\n';
            content += '|---|---|---|---|---|---|---|---|\n';
            content += tableRows.length ? tableRows.join('\n') + '\n' : '_No workflows found_\n';

            fs.writeFileSync('CI_STATUS.md', content);

      - name: Commit CI_STATUS.md update
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "CI monitor: update CI_STATUS.md"
          file_pattern: "CI_STATUS.md"
